import { untracked, reactive, derived, computed, deepEqual, effect, signal, batch, effects } from '@dnd-kit/state';
import { Position } from '@dnd-kit/geometry';

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};

// src/core/plugins/utilities.ts
function configure(plugin, options) {
  return {
    plugin,
    options
  };
}
function configurator(plugin) {
  return (options) => {
    return configure(plugin, options);
  };
}
function descriptor(plugin) {
  if (typeof plugin === "function") {
    return {
      plugin,
      options: void 0
    };
  }
  return plugin;
}

// src/core/plugins/plugin.ts
var Plugin = class {
  constructor(manager, options) {
    this.manager = manager;
    this.options = options;
  }
  disabled = false;
  /**
   * Enable a disabled plugin instance.
   * Triggers effects.
   */
  enable() {
    this.disabled = false;
  }
  /**
   * Disable an enabled plugin instance.
   * Triggers effects.
   */
  disable() {
    this.disabled = true;
  }
  /**
   * Whether the plugin instance is disabled.
   * Does not trigger effects when accessed.
   */
  isDisabled() {
    return untracked(() => {
      return this.disabled;
    });
  }
  /**
   * Configure a plugin instance with new options.
   */
  configure(options) {
    this.options = options;
  }
  /**
   * Destroy a plugin instance.
   */
  destroy() {
  }
  /**
   * Configure a plugin constructor with options.
   * This method is used to configure the options that the
   * plugin constructor will use to create plugin instances.
   */
  static configure(options) {
    return configure(this, options);
  }
};
__decorateClass([
  reactive
], Plugin.prototype, "disabled", 2);
var CorePlugin = class extends Plugin {
};

// src/core/plugins/registry.ts
var PluginRegistry = class {
  constructor(manager) {
    this.manager = manager;
  }
  instances = /* @__PURE__ */ new Map();
  get values() {
    return Array.from(this.instances.values());
  }
  #previousValues = [];
  set values(entries) {
    const descriptors = entries.map(descriptor);
    const constructors = descriptors.map(({ plugin }) => plugin);
    for (const plugin of this.#previousValues) {
      if (!constructors.includes(plugin)) {
        if (plugin.prototype instanceof CorePlugin) {
          continue;
        }
        this.unregister(plugin);
      }
    }
    for (const { plugin, options } of descriptors) {
      this.register(plugin, options);
    }
    this.#previousValues = constructors;
  }
  get(plugin) {
    const instance = this.instances.get(plugin);
    return instance;
  }
  register(plugin, options) {
    const existingInstance = this.instances.get(plugin);
    if (existingInstance) {
      return existingInstance;
    }
    const instance = new plugin(this.manager, options);
    this.instances.set(plugin, instance);
    return instance;
  }
  unregister(plugin) {
    const instance = this.instances.get(plugin);
    if (instance) {
      instance.destroy();
      this.instances.delete(plugin);
    }
  }
  destroy() {
    for (const plugin of this.instances.values()) {
      plugin.destroy();
    }
    this.instances.clear();
  }
};

// src/core/collision/utilities.ts
function sortCollisions(a, b) {
  if (a.priority === b.priority) {
    return b.value - a.value;
  }
  return b.priority - a.priority;
}

// src/core/collision/observer.ts
var DEFAULT_VALUE = [];
var CollisionObserver = class extends Plugin {
  constructor(manager) {
    super(manager);
    this.computeCollisions = this.computeCollisions.bind(this);
    this.#collisions = computed(this.computeCollisions, deepEqual);
    this.destroy = effect(() => {
      const { dragOperation } = this.manager;
      if (dragOperation.status.initialized) {
        this.forceUpdate();
      }
    });
  }
  forceUpdateCount = signal(0);
  forceUpdate(refresh = true) {
    untracked(() => {
      const { source } = this.manager.dragOperation;
      batch(() => {
        if (refresh) {
          for (const droppable of this.manager.registry.droppables) {
            if (source && !droppable.accepts(source)) {
              continue;
            }
            droppable.refreshShape();
          }
        }
        this.forceUpdateCount.value++;
      });
    });
  }
  computeCollisions(entries, collisionDetector) {
    const { registry, dragOperation } = this.manager;
    const { source, shape, status } = dragOperation;
    if (!status.initialized || !shape) {
      return DEFAULT_VALUE;
    }
    const collisions = [];
    this.forceUpdateCount.value;
    for (const entry of entries ?? registry.droppables) {
      if (entry.disabled) {
        continue;
      }
      if (source && !entry.accepts(source)) {
        continue;
      }
      const detectCollision = collisionDetector ?? entry.collisionDetector;
      if (!detectCollision) {
        continue;
      }
      const collision = untracked(
        () => detectCollision({
          droppable: entry,
          dragOperation
        })
      );
      if (collision) {
        if (entry.collisionPriority != null) {
          collision.priority = entry.collisionPriority;
        }
        collisions.push(collision);
      }
    }
    collisions.sort(sortCollisions);
    return collisions;
  }
  get collisions() {
    return this.#collisions.value;
  }
  #collisions;
};

// src/core/manager/events.ts
var Monitor = class {
  registry = /* @__PURE__ */ new Map();
  addEventListener(name, handler) {
    const { registry } = this;
    const listeners = new Set(registry.get(name));
    listeners.add(handler);
    registry.set(name, listeners);
    return () => this.removeEventListener(name, handler);
  }
  removeEventListener(name, handler) {
    const { registry } = this;
    const listeners = new Set(registry.get(name));
    listeners.delete(handler);
    registry.set(name, listeners);
  }
  dispatch(name, ...args) {
    const { registry } = this;
    const listeners = registry.get(name);
    if (!listeners) {
      return;
    }
    for (const listener of listeners) {
      listener(...args);
    }
  }
};
var DragDropMonitor = class extends Monitor {
  constructor(manager) {
    super();
    this.manager = manager;
  }
  dispatch(type, event) {
    const args = [event, this.manager];
    super.dispatch(type, ...args);
  }
};
function defaultPreventable(event, cancelable = true) {
  let defaultPrevented = false;
  return {
    ...event,
    cancelable,
    get defaultPrevented() {
      return defaultPrevented;
    },
    preventDefault() {
      if (!cancelable) {
        return;
      }
      defaultPrevented = true;
    }
  };
}

// src/core/collision/notifier.ts
var CollisionNotifier = class extends CorePlugin {
  constructor(manager) {
    super(manager);
    this.destroy = effect(() => {
      const { collisionObserver, monitor } = manager;
      const { collisions } = collisionObserver;
      if (collisionObserver.isDisabled()) {
        return;
      }
      const event = defaultPreventable({
        collisions
      });
      monitor.dispatch("collision", event);
      if (event.defaultPrevented) {
        return;
      }
      const [firstCollision] = collisions;
      untracked(() => {
        if (firstCollision?.id !== manager.dragOperation.target?.id) {
          collisionObserver.disable();
          manager.actions.setDropTarget(firstCollision?.id).then(() => {
            collisionObserver.enable();
          });
        }
      });
    });
  }
};

// src/core/collision/types.ts
var CollisionPriority = /* @__PURE__ */ ((CollisionPriority2) => {
  CollisionPriority2[CollisionPriority2["Lowest"] = 0] = "Lowest";
  CollisionPriority2[CollisionPriority2["Low"] = 1] = "Low";
  CollisionPriority2[CollisionPriority2["Normal"] = 2] = "Normal";
  CollisionPriority2[CollisionPriority2["High"] = 3] = "High";
  CollisionPriority2[CollisionPriority2["Highest"] = 4] = "Highest";
  return CollisionPriority2;
})(CollisionPriority || {});
function getDefaultEffects() {
  return [];
}
var Entity = class {
  /**
   * Creates a new instance of the `Entity` class.
   *
   * @param input - An object containing the initial properties of the entity.
   * @param manager - The manager that controls the drag and drop operations.
   */
  constructor(input, manager) {
    this.manager = manager;
    const {
      effects: getEffects = getDefaultEffects,
      id,
      options,
      data = null,
      disabled = false
    } = input;
    let previousId = id;
    this.id = id;
    this.data = data;
    this.disabled = disabled;
    this.effects = [
      () => {
        if (id === previousId) {
          return;
        }
        manager.registry.register(this);
        return () => manager.registry.unregister(this);
      },
      ...getEffects()
    ];
    this.destroy = this.destroy.bind(this);
    if (options?.register !== false) {
      queueMicrotask(() => {
        manager.registry.register(this);
      });
    }
  }
  id;
  data;
  disabled;
  /**
   * An array of effects that are applied to the entity.
   */
  effects;
  /**
   * A method that cleans up the entity when it is no longer needed.
   * @returns void
   */
  destroy() {
    this.manager.registry.unregister(this);
  }
};
__decorateClass([
  reactive
], Entity.prototype, "id", 2);
__decorateClass([
  reactive
], Entity.prototype, "data", 2);
__decorateClass([
  reactive
], Entity.prototype, "disabled", 2);
var EntityRegistry = class {
  map = signal(/* @__PURE__ */ new Map());
  cleanupFunctions = /* @__PURE__ */ new WeakMap();
  /**
   * Iterator for the EntityRegistry class.
   * @returns An iterator for the values in the map.
   */
  [Symbol.iterator]() {
    return this.map.peek().values();
  }
  get value() {
    return this.map.value.values();
  }
  /**
   * Checks if a entity with the given identifier exists in the registry.
   * @param identifier - The unique identifier of the entity.
   * @returns True if the entity exists, false otherwise.
   */
  has(identifier) {
    return this.map.value.has(identifier);
  }
  /**
   * Retrieves a entity from the registry using its identifier.
   * @param identifier - The unique identifier of the entity.
   * @returns The entity if it exists, undefined otherwise.
   */
  get(identifier) {
    return this.map.value.get(identifier);
  }
  /**
   * Registers a entity in the registry.
   * @param key - The unique identifier of the entity.
   * @param value - The entity to register.
   * @returns A function that unregisters the entity.
   */
  register = (key, value) => {
    const current = this.map.peek();
    if (current.get(key) === value) {
      return;
    }
    const updatedMap = new Map(current);
    updatedMap.set(key, value);
    this.map.value = updatedMap;
    const cleanup = effects(...value.effects);
    this.cleanupFunctions.set(value, cleanup);
    return () => this.unregister(key, value);
  };
  /**
   * Unregisters an entity from the registry.
   * @param key - The unique identifier of the entity.
   * @param value - The entity instance to unregister.
   */
  unregister = (key, value) => {
    const current = this.map.peek();
    if (current.get(key) !== value) {
      return;
    }
    const cleanup = this.cleanupFunctions.get(value);
    cleanup?.();
    this.cleanupFunctions.delete(value);
    const updatedMap = new Map(current);
    updatedMap.delete(key);
    this.map.value = updatedMap;
  };
  /**
   * Destroys all entries in the registry and clears the registry.
   */
  destroy() {
    for (const entry of this) {
      const cleanup = this.cleanupFunctions.get(entry);
      cleanup?.();
      entry.destroy();
    }
    this.map.value = /* @__PURE__ */ new Map();
  }
};
var Draggable = class extends Entity {
  constructor({ modifiers, type, sensors, ...input }, manager) {
    super(input, manager);
    this.manager = manager;
    this.type = type;
    this.sensors = sensors;
    if (modifiers?.length) {
      this.modifiers = modifiers.map((modifier) => {
        const { plugin, options } = descriptor(modifier);
        return new plugin(manager, options);
      });
    }
  }
  sensors;
  modifiers;
  type;
  get isDragSource() {
    const { dragOperation } = this.manager;
    return dragOperation.source?.id === this.id;
  }
  destroy() {
    super.destroy();
    this.modifiers?.forEach((modifier) => modifier.destroy());
  }
};
__decorateClass([
  reactive
], Draggable.prototype, "type", 2);
__decorateClass([
  derived
], Draggable.prototype, "isDragSource", 1);
var Droppable = class extends Entity {
  constructor({
    accept,
    collisionDetector,
    collisionPriority = 2 /* Normal */,
    type,
    ...input
  }, manager) {
    super(input, manager);
    this.manager = manager;
    this.accept = accept;
    this.collisionDetector = collisionDetector;
    this.collisionPriority = collisionPriority;
    this.type = type;
  }
  accept;
  type;
  /**
   * Checks whether or not the droppable accepts a given draggable.
   *
   * @param {Draggable} draggable
   * @returns {boolean}
   */
  accepts(draggable) {
    const { accept } = this;
    if (!accept) {
      return true;
    }
    if (!draggable.type) {
      return false;
    }
    if (Array.isArray(accept)) {
      return accept.includes(draggable.type);
    }
    if (typeof accept === "function") {
      return accept(draggable);
    }
    return draggable.type === accept;
  }
  collisionDetector;
  collisionPriority;
  shape;
  get isDropTarget() {
    return this.manager.dragOperation.target?.id === this.id;
  }
  refreshShape() {
  }
};
__decorateClass([
  reactive
], Droppable.prototype, "accept", 2);
__decorateClass([
  reactive
], Droppable.prototype, "type", 2);
__decorateClass([
  reactive
], Droppable.prototype, "collisionDetector", 2);
__decorateClass([
  reactive
], Droppable.prototype, "collisionPriority", 2);
__decorateClass([
  reactive
], Droppable.prototype, "shape", 2);
__decorateClass([
  derived
], Droppable.prototype, "isDropTarget", 1);

// src/core/sensors/sensor.ts
var Sensor = class extends Plugin {
  constructor(manager, options) {
    super(manager, options);
    this.manager = manager;
    this.options = options;
  }
};

// src/core/modifiers/modifier.ts
var Modifier = class extends Plugin {
  constructor(manager, options) {
    super(manager, options);
    this.manager = manager;
    this.options = options;
  }
  apply(operation) {
    return operation.transform;
  }
};

// src/core/manager/registry.ts
var DragDropRegistry = class {
  constructor(manager) {
    this.plugins = new PluginRegistry(manager);
    this.sensors = new PluginRegistry(manager);
    this.modifiers = new PluginRegistry(manager);
  }
  draggables = new EntityRegistry();
  droppables = new EntityRegistry();
  plugins;
  sensors;
  modifiers;
  register(input, options) {
    if (input instanceof Draggable) {
      return this.draggables.register(input.id, input);
    }
    if (input instanceof Droppable) {
      return this.droppables.register(input.id, input);
    }
    if (input.prototype instanceof Modifier) {
      return this.modifiers.register(input, options);
    }
    if (input.prototype instanceof Sensor) {
      return this.sensors.register(input, options);
    }
    if (input.prototype instanceof Plugin) {
      return this.plugins.register(input, options);
    }
    throw new Error("Invalid instance type");
  }
  unregister(input) {
    if (input instanceof Entity) {
      if (input instanceof Draggable) {
        return this.draggables.unregister(input.id, input);
      }
      if (input instanceof Droppable) {
        return this.droppables.unregister(input.id, input);
      }
      return () => {
      };
    }
    if (input.prototype instanceof Modifier) {
      return this.modifiers.unregister(input);
    }
    if (input.prototype instanceof Sensor) {
      return this.sensors.unregister(input);
    }
    if (input.prototype instanceof Plugin) {
      return this.plugins.unregister(input);
    }
    throw new Error("Invalid instance type");
  }
  destroy() {
    this.draggables.destroy();
    this.droppables.destroy();
    this.plugins.destroy();
    this.sensors.destroy();
    this.modifiers.destroy();
  }
};
var Status = /* @__PURE__ */ ((Status2) => {
  Status2["Idle"] = "idle";
  Status2["Initializing"] = "initializing";
  Status2["Dragging"] = "dragging";
  Status2["Dropped"] = "dropped";
  return Status2;
})(Status || {});
function DragOperationManager(manager) {
  const {
    registry: { draggables, droppables },
    monitor
  } = manager;
  const status = signal("idle" /* Idle */);
  const shape = {
    initial: signal(null),
    current: signal(null)
  };
  const canceled = signal(false);
  const position = new Position({ x: 0, y: 0 });
  const activatorEvent = signal(null);
  const sourceIdentifier = signal(null);
  const targetIdentifier = signal(null);
  const dragging = computed(() => status.value === "dragging" /* Dragging */);
  const initialized = computed(() => status.value !== "idle" /* Idle */);
  const initializing = computed(() => status.value === "initializing" /* Initializing */);
  const idle = computed(() => status.value === "idle" /* Idle */);
  const dropped = computed(() => status.value === "dropped" /* Dropped */);
  const dragended = signal(true);
  let previousSource;
  const source = computed(() => {
    const identifier = sourceIdentifier.value;
    if (identifier == null)
      return null;
    const value = draggables.get(identifier);
    if (value) {
      previousSource = value;
    }
    return value ?? previousSource ?? null;
  });
  const target = computed(() => {
    const identifier = targetIdentifier.value;
    return identifier != null ? droppables.get(identifier) ?? null : null;
  });
  const transform = computed(() => {
    const { x, y } = position.delta;
    const modifiers = source?.value?.modifiers ?? manager.modifiers;
    let transform2 = { x, y };
    const initialShape = shape.initial.peek();
    const currentShape = shape.current.peek();
    const operation2 = {
      activatorEvent: activatorEvent.peek(),
      canceled: canceled.peek(),
      source: source.peek(),
      target: target.peek(),
      status: {
        current: status.peek(),
        idle: idle.peek(),
        initializing: initializing.peek(),
        initialized: initialized.peek(),
        dragging: dragging.peek(),
        dragended: dragended.peek(),
        dropped: dropped.peek()
      },
      shape: initialShape && currentShape ? { initial: initialShape, current: currentShape } : null,
      position
    };
    for (const modifier of modifiers) {
      transform2 = modifier.apply({ ...operation2, transform: transform2 });
    }
    return transform2;
  });
  const operation = {
    get activatorEvent() {
      return activatorEvent.value;
    },
    get canceled() {
      return canceled.value;
    },
    get source() {
      return source.value;
    },
    get target() {
      return target.value;
    },
    status: {
      get current() {
        return status.value;
      },
      get idle() {
        return idle.value;
      },
      get initializing() {
        return initializing.value;
      },
      get initialized() {
        return initialized.value;
      },
      get dragging() {
        return dragging.value;
      },
      get dragended() {
        return dragended.value;
      },
      get dropped() {
        return dropped.value;
      }
    },
    get shape() {
      const initial = shape.initial.value;
      const current = shape.current.value;
      return initial && current ? { initial, current } : null;
    },
    set shape(value) {
      if (value && shape.current.peek()?.equals(value)) {
        return;
      }
      const initial = shape.initial.peek();
      if (!initial) {
        shape.initial.value = value;
      }
      shape.current.value = value;
    },
    get transform() {
      return transform.value;
    },
    position
  };
  const reset = () => {
    batch(() => {
      status.value = "idle" /* Idle */;
      sourceIdentifier.value = null;
      targetIdentifier.value = null;
      shape.current.value = null;
      shape.initial.value = null;
      position.reset({ x: 0, y: 0 });
    });
  };
  return {
    operation,
    actions: {
      setDragSource(identifier) {
        sourceIdentifier.value = identifier;
      },
      setDropTarget(identifier) {
        const id = identifier ?? null;
        if (targetIdentifier.peek() === id) {
          return Promise.resolve();
        }
        targetIdentifier.value = id;
        if (status.peek() === "dragging" /* Dragging */) {
          monitor.dispatch(
            "dragover",
            defaultPreventable({
              operation: snapshot(operation)
            })
          );
        }
        return manager.renderer.rendering;
      },
      start({ event, coordinates }) {
        batch(() => {
          dragended.value = false;
          canceled.value = false;
          activatorEvent.value = event;
          position.reset(coordinates);
        });
        const beforeStartEvent = defaultPreventable({
          operation: snapshot(operation)
        });
        monitor.dispatch("beforedragstart", beforeStartEvent);
        manager.renderer.rendering.then(() => {
          if (beforeStartEvent.defaultPrevented) {
            reset();
            return;
          }
          status.value = "initializing" /* Initializing */;
          requestAnimationFrame(() => {
            status.value = "dragging" /* Dragging */;
            monitor.dispatch("dragstart", {
              operation: snapshot(operation),
              cancelable: false
            });
          });
        });
      },
      move({
        by,
        to,
        cancelable = true
      }) {
        if (!dragging.peek()) {
          return;
        }
        const event = defaultPreventable(
          {
            operation: snapshot(operation),
            by,
            to
          },
          cancelable
        );
        monitor.dispatch("dragmove", event);
        queueMicrotask(() => {
          if (event.defaultPrevented) {
            return;
          }
          const coordinates = to ?? {
            x: position.current.x + by.x,
            y: position.current.y + by.y
          };
          position.update(coordinates);
        });
      },
      stop({ canceled: eventCanceled = false } = {}) {
        let promise;
        const suspend = () => {
          const output = {
            resume: () => {
            },
            abort: () => {
            }
          };
          promise = new Promise((resolve, reject) => {
            output.resume = resolve;
            output.abort = reject;
          });
          return output;
        };
        const end = () => {
          manager.renderer.rendering.then(() => {
            status.value = "dropped" /* Dropped */;
            manager.renderer.rendering.then(reset);
          });
        };
        batch(() => {
          dragended.value = true;
          canceled.value = eventCanceled;
        });
        monitor.dispatch("dragend", {
          operation: snapshot(operation),
          canceled: eventCanceled,
          suspend
        });
        if (promise) {
          promise.then(end).catch(reset);
        } else {
          end();
        }
      }
    }
  };
}
function snapshot(obj) {
  return {
    ...obj
  };
}

// src/core/manager/renderer.ts
var defaultRenderer = {
  get rendering() {
    return Promise.resolve();
  }
};

// src/core/manager/manager.ts
var DragDropManager = class {
  actions;
  collisionObserver;
  dragOperation;
  monitor;
  registry;
  renderer;
  constructor(config) {
    const {
      plugins = [],
      sensors = [],
      modifiers = [],
      renderer = defaultRenderer
    } = config ?? {};
    const monitor = new DragDropMonitor(this);
    const registry = new DragDropRegistry(this);
    this.registry = registry;
    this.monitor = monitor;
    this.renderer = renderer;
    const { actions, operation } = DragOperationManager(this);
    this.actions = actions;
    this.dragOperation = operation;
    this.collisionObserver = new CollisionObserver(this);
    this.plugins = [CollisionNotifier, ...plugins];
    this.modifiers = modifiers;
    this.sensors = sensors;
  }
  get plugins() {
    return this.registry.plugins.values;
  }
  set plugins(plugins) {
    this.registry.plugins.values = plugins;
  }
  get modifiers() {
    return this.registry.modifiers.values;
  }
  set modifiers(modifiers) {
    this.registry.modifiers.values = modifiers;
  }
  get sensors() {
    return this.registry.sensors.values;
  }
  set sensors(sensors) {
    this.registry.sensors.values = sensors;
  }
  destroy() {
    this.registry.destroy();
    this.collisionObserver.destroy();
  }
};

export { CollisionPriority, CorePlugin, DragDropManager, Status as DragOperationStatus, Draggable, Droppable, Modifier, Plugin, PluginRegistry, Sensor, configurator, configure, descriptor, sortCollisions };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=index.js.map