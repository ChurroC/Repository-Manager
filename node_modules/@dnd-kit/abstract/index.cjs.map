{"version":3,"sources":["src/core/collision/observer.ts","src/core/plugins/plugin.ts","src/core/plugins/utilities.ts","src/core/plugins/registry.ts","src/core/collision/utilities.ts","src/core/collision/notifier.ts","src/core/manager/events.ts","src/core/collision/types.ts","src/core/entities/entity/entity.ts","src/core/entities/entity/registry.ts","src/core/entities/draggable/draggable.ts","src/core/entities/droppable/droppable.ts","src/core/sensors/sensor.ts","src/core/modifiers/modifier.ts","src/core/manager/registry.ts","src/core/manager/dragOperation.ts","src/core/manager/renderer.ts","src/core/manager/manager.ts"],"names":["untracked","effect","CollisionPriority","reactive","effects","signal","derived","batch","computed","Status","transform","operation"],"mappings":"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","sourcesContent":["import {\n  batch,\n  computed,\n  deepEqual,\n  signal,\n  untracked,\n  type ReadonlySignal,\n  effect,\n} from '@dnd-kit/state';\n\nimport type {DragDropManager} from '../manager/index.ts';\nimport type {Draggable, Droppable} from '../entities/index.ts';\nimport {Plugin} from '../plugins/index.ts';\nimport type {Collision, CollisionDetector, Collisions} from './types.ts';\nimport {sortCollisions} from './utilities.ts';\n\nconst DEFAULT_VALUE: Collisions = [];\n\nexport class CollisionObserver<\n  T extends Draggable = Draggable,\n  U extends Droppable = Droppable,\n  V extends DragDropManager<T, U> = DragDropManager<T, U>,\n> extends Plugin<V> {\n  constructor(manager: V) {\n    super(manager);\n\n    this.computeCollisions = this.computeCollisions.bind(this);\n    this.#collisions = computed(this.computeCollisions, deepEqual);\n\n    this.destroy = effect(() => {\n      const {dragOperation} = this.manager;\n\n      if (dragOperation.status.initialized) {\n        this.forceUpdate();\n      }\n    });\n  }\n\n  forceUpdateCount = signal(0);\n\n  public forceUpdate(refresh = true) {\n    untracked(() => {\n      const {source} = this.manager.dragOperation;\n\n      batch(() => {\n        if (refresh) {\n          for (const droppable of this.manager.registry.droppables) {\n            if (source && !droppable.accepts(source)) {\n              continue;\n            }\n\n            droppable.refreshShape();\n          }\n        }\n\n        this.forceUpdateCount.value++;\n      });\n    });\n  }\n\n  public computeCollisions(\n    entries?: Droppable[],\n    collisionDetector?: CollisionDetector\n  ) {\n    const {registry, dragOperation} = this.manager;\n    const {source, shape, status} = dragOperation;\n\n    if (!status.initialized || !shape) {\n      return DEFAULT_VALUE;\n    }\n\n    const collisions: Collision[] = [];\n\n    this.forceUpdateCount.value;\n\n    for (const entry of entries ?? registry.droppables) {\n      if (entry.disabled) {\n        continue;\n      }\n\n      if (source && !entry.accepts(source)) {\n        continue;\n      }\n\n      const detectCollision = collisionDetector ?? entry.collisionDetector;\n\n      if (!detectCollision) {\n        continue;\n      }\n\n      const collision = untracked(() =>\n        detectCollision({\n          droppable: entry,\n          dragOperation,\n        })\n      );\n\n      if (collision) {\n        if (entry.collisionPriority != null) {\n          collision.priority = entry.collisionPriority;\n        }\n\n        collisions.push(collision);\n      }\n    }\n\n    collisions.sort(sortCollisions);\n\n    return collisions;\n  }\n\n  public get collisions() {\n    return this.#collisions.value;\n  }\n\n  #collisions: ReadonlySignal<Collisions>;\n}\n","import {reactive, untracked} from '@dnd-kit/state';\n\nimport type {DragDropManager} from '../manager/index.ts';\nimport type {PluginOptions} from './types.ts';\nimport {configure} from './utilities.ts';\n\n/**\n * An abstract plugin class that can be extended to implement custom\n * functionality that augments the `DragDropManager`'s core capabilities.\n */\nexport abstract class Plugin<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n  U extends PluginOptions = PluginOptions,\n> {\n  constructor(\n    public manager: T,\n    public options?: U\n  ) {}\n\n  /**\n   * Whether the plugin instance is disabled.\n   * Triggers effects when accessed.\n   */\n  @reactive\n  public disabled: boolean = false;\n\n  /**\n   * Enable a disabled plugin instance.\n   * Triggers effects.\n   */\n  public enable() {\n    this.disabled = false;\n  }\n\n  /**\n   * Disable an enabled plugin instance.\n   * Triggers effects.\n   */\n  public disable() {\n    this.disabled = true;\n  }\n\n  /**\n   * Whether the plugin instance is disabled.\n   * Does not trigger effects when accessed.\n   */\n  public isDisabled() {\n    return untracked(() => {\n      return this.disabled;\n    });\n  }\n\n  /**\n   * Configure a plugin instance with new options.\n   */\n  public configure(options?: U) {\n    this.options = options;\n  }\n\n  /**\n   * Destroy a plugin instance.\n   */\n  public destroy() {\n    /*\n     * Each plugin is responsible for implementing its own\n     * destroy method to clean up effects and listeners\n     */\n  }\n\n  /**\n   * Configure a plugin constructor with options.\n   * This method is used to configure the options that the\n   * plugin constructor will use to create plugin instances.\n   */\n  static configure(options: PluginOptions) {\n    return configure(this as any, options);\n  }\n}\n\nexport class CorePlugin<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n  U extends PluginOptions = PluginOptions,\n> extends Plugin<T, U> {}\n","import type {\n  PluginConstructor,\n  PluginOptions,\n  PluginDescriptor,\n  InferPluginOptions,\n} from './types.ts';\n\nexport function configure<\n  T extends PluginConstructor<any, any, any>,\n  V extends PluginOptions = InferPluginOptions<T>,\n>(plugin: T, options: V): PluginDescriptor<any, any, T> {\n  return {\n    plugin,\n    options,\n  };\n}\n\nexport function configurator<T extends PluginConstructor<any, any, any>>(\n  plugin: T\n) {\n  return (options: InferPluginOptions<T>): PluginDescriptor<any, any, T> => {\n    return configure(plugin, options);\n  };\n}\n\nexport function descriptor<T extends PluginConstructor<any, any, any>>(\n  plugin: T | PluginDescriptor<any, any, T>\n): PluginDescriptor<any, any, T> {\n  if (typeof plugin === 'function') {\n    return {\n      plugin,\n      options: undefined,\n    };\n  }\n\n  return plugin;\n}\n","import {DragDropManager} from '../manager/index.ts';\nimport {CorePlugin, type Plugin} from './plugin.ts';\nimport type {InferPluginOptions, PluginConstructor, Plugins} from './types.ts';\nimport {descriptor} from './utilities.ts';\n\nexport class PluginRegistry<\n  T extends DragDropManager<any, any>,\n  W extends PluginConstructor<T> = PluginConstructor<T>,\n  U extends Plugin<T> = InstanceType<W>,\n> {\n  private instances: Map<W, U> = new Map();\n\n  constructor(private manager: T) {}\n\n  public get values(): U[] {\n    return Array.from(this.instances.values());\n  }\n\n  #previousValues: PluginConstructor<T>[] = [];\n\n  public set values(entries: Plugins<T>) {\n    const descriptors = entries.map(descriptor);\n    const constructors = descriptors.map(({plugin}) => plugin);\n\n    for (const plugin of this.#previousValues) {\n      if (!constructors.includes(plugin)) {\n        if (plugin.prototype instanceof CorePlugin) {\n          continue;\n        }\n\n        this.unregister(plugin as W);\n      }\n    }\n\n    for (const {plugin, options} of descriptors) {\n      this.register(plugin as W, options as InferPluginOptions<W>);\n    }\n\n    this.#previousValues = constructors;\n  }\n\n  public get<X extends W>(plugin: X): InstanceType<X> | undefined {\n    const instance = this.instances.get(plugin);\n\n    return instance as any;\n  }\n\n  public register<X extends W>(\n    plugin: X,\n    options?: InferPluginOptions<X>\n  ): InstanceType<X> {\n    const existingInstance = this.instances.get(plugin);\n\n    if (existingInstance) {\n      return existingInstance as InstanceType<X>;\n    }\n\n    const instance = new plugin(this.manager, options) as U;\n\n    this.instances.set(plugin, instance);\n\n    return instance as InstanceType<X>;\n  }\n\n  public unregister<X extends W>(plugin: X) {\n    const instance = this.instances.get(plugin);\n\n    if (instance) {\n      instance.destroy();\n      this.instances.delete(plugin);\n    }\n  }\n\n  public destroy() {\n    for (const plugin of this.instances.values()) {\n      plugin.destroy();\n    }\n\n    this.instances.clear();\n  }\n}\n","import {Collision} from './types.ts';\n\n/**\n * Sort collisions from greatest to smallest priority\n * Collisions of equal priority are sorted from greatest to smallest value\n */\nexport function sortCollisions(a: Collision, b: Collision) {\n  if (a.priority === b.priority) {\n    return b.value - a.value;\n  }\n\n  return b.priority - a.priority;\n}\n","import {effect, untracked} from '@dnd-kit/state';\n\nimport {DragDropManager} from '../manager/index.ts';\nimport {CorePlugin} from '../plugins/index.ts';\nimport {defaultPreventable} from '../manager/events.ts';\n\nexport class CollisionNotifier extends CorePlugin {\n  constructor(manager: DragDropManager) {\n    super(manager);\n\n    this.destroy = effect(() => {\n      const {collisionObserver, monitor} = manager;\n      const {collisions} = collisionObserver;\n\n      if (collisionObserver.isDisabled()) {\n        return;\n      }\n\n      const event = defaultPreventable({\n        collisions,\n      });\n\n      monitor.dispatch('collision', event);\n\n      if (event.defaultPrevented) {\n        return;\n      }\n\n      const [firstCollision] = collisions;\n\n      untracked(() => {\n        if (firstCollision?.id !== manager.dragOperation.target?.id) {\n          collisionObserver.disable();\n\n          manager.actions.setDropTarget(firstCollision?.id).then(() => {\n            collisionObserver.enable();\n          });\n        }\n      });\n    });\n  }\n}\n","import type {Coordinates} from '@dnd-kit/geometry';\n\nimport type {Draggable, Droppable} from '../entities/index.ts';\nimport type {Collisions} from '../collision/index.ts';\nimport type {DragDropManager} from './manager.ts';\nimport type {DragOperation} from './dragOperation.ts';\n\nexport type Events = Record<string, (...args: any[]) => void>;\n\nexport type Preventable<T> = T & {\n  cancelable: boolean;\n  defaultPrevented: boolean;\n  preventDefault(): void;\n};\n\nclass Monitor<T extends Events> {\n  private registry = new Map<keyof T, Set<T[keyof T]>>();\n\n  public addEventListener<U extends keyof T>(name: U, handler: T[U]) {\n    const {registry} = this;\n    const listeners = new Set(registry.get(name));\n\n    listeners.add(handler);\n    registry.set(name, listeners);\n\n    return () => this.removeEventListener(name, handler);\n  }\n\n  public removeEventListener(name: keyof T, handler: T[keyof T]) {\n    const {registry} = this;\n    const listeners = new Set(registry.get(name));\n\n    listeners.delete(handler);\n    registry.set(name, listeners);\n  }\n\n  protected dispatch<U extends keyof T>(name: U, ...args: any[]) {\n    const {registry} = this;\n    const listeners = registry.get(name);\n\n    if (!listeners) {\n      return;\n    }\n\n    for (const listener of listeners) {\n      listener(...args);\n    }\n  }\n}\n\nexport type DragDropEvents<\n  T extends Draggable,\n  U extends Droppable,\n  V extends DragDropManager<T, U>,\n> = {\n  collision(\n    event: Preventable<{\n      collisions: Collisions;\n    }>,\n    manager: V\n  ): void;\n  beforedragstart(\n    event: Preventable<{operation: DragOperation<T, U>}>,\n    manager: V\n  ): void;\n  dragstart(\n    event: {\n      cancelable: false;\n      operation: DragOperation<T, U>;\n    },\n    manager: V\n  ): void;\n  dragmove(\n    event: Preventable<{\n      operation: DragOperation<T, U>;\n      to?: Coordinates;\n      by?: Coordinates;\n    }>,\n    manager: V\n  ): void;\n  dragover(\n    event: Preventable<{\n      operation: DragOperation<T, U>;\n    }>,\n    manager: V\n  ): void;\n  dragend(\n    event: {\n      operation: DragOperation<T, U>;\n      canceled: boolean;\n      suspend(): {resume(): void; abort(): void};\n    },\n    manager: V\n  ): void;\n};\n\nexport class DragDropMonitor<\n  T extends Draggable,\n  U extends Droppable,\n  V extends DragDropManager<T, U>,\n> extends Monitor<DragDropEvents<T, U, V>> {\n  constructor(private manager: V) {\n    super();\n  }\n\n  public dispatch<Key extends keyof DragDropEvents<T, U, V>>(\n    type: Key,\n    event: Parameters<DragDropEvents<T, U, V>[Key]>[0]\n  ) {\n    const args = [event, this.manager] as any;\n\n    super.dispatch(type, ...args);\n  }\n}\n\nexport function defaultPreventable<T>(\n  event: T,\n  cancelable = true\n): Preventable<T> {\n  let defaultPrevented = false;\n\n  return {\n    ...event,\n    cancelable,\n    get defaultPrevented() {\n      return defaultPrevented;\n    },\n    preventDefault() {\n      if (!cancelable) {\n        return;\n      }\n\n      defaultPrevented = true;\n    },\n  };\n}\n","import type {DragOperation} from '../manager/index.ts';\nimport type {\n  Draggable,\n  Droppable,\n  UniqueIdentifier,\n} from '../entities/index.ts';\n\nexport enum CollisionPriority {\n  Lowest,\n  Low,\n  Normal,\n  High,\n  Highest,\n}\n\nexport interface Collision {\n  id: UniqueIdentifier;\n  priority: CollisionPriority | number;\n  value: number;\n}\n\nexport type Collisions = Collision[];\n\nexport interface CollisionDetectorInput<\n  T extends Draggable = Draggable,\n  U extends Droppable = Droppable,\n> {\n  droppable: U;\n  dragOperation: DragOperation<T, U>;\n}\n\nexport type CollisionDetector = <\n  T extends Draggable = Draggable,\n  U extends Droppable = Droppable,\n>(\n  input: CollisionDetectorInput<T, U>\n) => Collision | null;\n","import {effects, reactive, type Effect} from '@dnd-kit/state';\n\nimport type {DragDropManager} from '../../manager/index.ts';\nimport type {Data, UniqueIdentifier} from './types.ts';\n\ninterface Options {\n  /**\n   * A boolean indicating whether the entity should automatically be registered with the manager.\n   * @defaultValue true\n   */\n  register?: boolean;\n}\n\nexport interface Input<T extends Data = Data> {\n  id: UniqueIdentifier;\n  data?: T | null;\n  disabled?: boolean;\n  options?: Options;\n  effects?(): Effect[];\n}\n\nfunction getDefaultEffects(): Effect[] {\n  return [];\n}\n\n/**\n * The `Entity` class is an abstract representation of a distinct unit in the drag and drop system.\n * It is a base class that other concrete classes like `Draggable` and `Droppable` can extend.\n *\n * @template T - The type of data associated with the entity.\n */\nexport class Entity<T extends Data = Data> {\n  /**\n   * Creates a new instance of the `Entity` class.\n   *\n   * @param input - An object containing the initial properties of the entity.\n   * @param manager - The manager that controls the drag and drop operations.\n   */\n  constructor(\n    input: Input<T>,\n    public manager: DragDropManager\n  ) {\n    const {\n      effects: getEffects = getDefaultEffects,\n      id,\n      options,\n      data = null,\n      disabled = false,\n    } = input;\n\n    let previousId = id;\n\n    this.id = id;\n    this.data = data;\n    this.disabled = disabled;\n    this.effects = [\n      () => {\n        // Re-run this effect whenever the `id` changes\n        const {id: _} = this;\n\n        if (id === previousId) {\n          return;\n        }\n\n        manager.registry.register(this);\n\n        return () => manager.registry.unregister(this);\n      },\n      ...getEffects(),\n    ];\n    this.destroy = this.destroy.bind(this);\n\n    if (options?.register !== false) {\n      queueMicrotask(() => {\n        manager.registry.register(this);\n      });\n    }\n  }\n\n  /**\n   * The unique identifier of the entity.\n   */\n  @reactive\n  public id: UniqueIdentifier;\n\n  /**\n   * The data associated with the entity.\n   */\n  @reactive\n  public data: Data | null;\n\n  /**\n   * A boolean indicating whether the entity is disabled.\n   */\n  @reactive\n  public disabled: boolean;\n\n  /**\n   * An array of effects that are applied to the entity.\n   */\n  public effects: Effect[];\n\n  /**\n   * A method that cleans up the entity when it is no longer needed.\n   * @returns void\n   */\n  public destroy(): void {\n    this.manager.registry.unregister(this);\n  }\n}\n","import {effects, signal} from '@dnd-kit/state';\n\nimport type {Entity} from './entity.ts';\nimport type {UniqueIdentifier} from './types.ts';\n\n/**\n * Reactive class representing a registry for entities.\n * @template T - The type of entries that the registry manages,\n * for example, `Draggable` or `Droppable` entities.\n */\nexport class EntityRegistry<T extends Entity> {\n  private map = signal<Map<UniqueIdentifier, T>>(new Map());\n  private cleanupFunctions = new WeakMap<T, () => void>();\n\n  /**\n   * Iterator for the EntityRegistry class.\n   * @returns An iterator for the values in the map.\n   */\n  public [Symbol.iterator]() {\n    return this.map.peek().values();\n  }\n\n  public get value() {\n    return this.map.value.values();\n  }\n\n  /**\n   * Checks if a entity with the given identifier exists in the registry.\n   * @param identifier - The unique identifier of the entity.\n   * @returns True if the entity exists, false otherwise.\n   */\n  public has(identifier: UniqueIdentifier): boolean {\n    return this.map.value.has(identifier);\n  }\n\n  /**\n   * Retrieves a entity from the registry using its identifier.\n   * @param identifier - The unique identifier of the entity.\n   * @returns The entity if it exists, undefined otherwise.\n   */\n  public get(identifier: UniqueIdentifier): T | undefined {\n    return this.map.value.get(identifier);\n  }\n\n  /**\n   * Registers a entity in the registry.\n   * @param key - The unique identifier of the entity.\n   * @param value - The entity to register.\n   * @returns A function that unregisters the entity.\n   */\n  public register = (key: UniqueIdentifier, value: T) => {\n    const current = this.map.peek();\n\n    if (current.get(key) === value) {\n      return;\n    }\n\n    const updatedMap = new Map(current);\n    updatedMap.set(key, value);\n\n    this.map.value = updatedMap;\n\n    const cleanup = effects(...value.effects);\n    this.cleanupFunctions.set(value, cleanup);\n\n    return () => this.unregister(key, value);\n  };\n\n  /**\n   * Unregisters an entity from the registry.\n   * @param key - The unique identifier of the entity.\n   * @param value - The entity instance to unregister.\n   */\n  public unregister = (key: UniqueIdentifier, value: T) => {\n    const current = this.map.peek();\n\n    if (current.get(key) !== value) {\n      return;\n    }\n\n    const cleanup = this.cleanupFunctions.get(value);\n    cleanup?.();\n    this.cleanupFunctions.delete(value);\n\n    const updatedMap = new Map(current);\n    updatedMap.delete(key);\n\n    this.map.value = updatedMap;\n  };\n\n  /**\n   * Destroys all entries in the registry and clears the registry.\n   */\n  public destroy() {\n    for (const entry of this) {\n      const cleanup = this.cleanupFunctions.get(entry);\n      cleanup?.();\n      entry.destroy();\n    }\n\n    this.map.value = new Map();\n  }\n}\n","import {derived, reactive} from '@dnd-kit/state';\n\nimport {Entity} from '../entity/index.ts';\nimport type {EntityInput, Data, Type} from '../entity/index.ts';\nimport {Modifier} from '../../modifiers/index.ts';\nimport type {Modifiers} from '../../modifiers/index.ts';\nimport type {DragDropManager} from '../../manager/index.ts';\nimport {descriptor} from '../../plugins/index.ts';\nimport type {Sensors} from '../../sensors/sensor.ts';\n\nexport interface Input<T extends Data = Data> extends EntityInput<T> {\n  type?: Type;\n  modifiers?: Modifiers;\n  sensors?: Sensors;\n}\n\nexport class Draggable<T extends Data = Data> extends Entity<T> {\n  constructor(\n    {modifiers, type, sensors, ...input}: Input<T>,\n    public manager: DragDropManager\n  ) {\n    super(input, manager);\n\n    this.type = type;\n    this.sensors = sensors;\n\n    if (modifiers?.length) {\n      this.modifiers = modifiers.map((modifier) => {\n        const {plugin, options} = descriptor(modifier);\n\n        return new plugin(manager, options);\n      });\n    }\n  }\n\n  public sensors: Sensors | undefined;\n\n  public modifiers: Modifier[] | undefined;\n\n  @reactive\n  public type: Type | undefined;\n\n  /**\n   * A boolean indicating whether the draggable item is the source of a drag operation.\n   */\n  @derived\n  public get isDragSource() {\n    const {dragOperation} = this.manager;\n\n    return dragOperation.source?.id === this.id;\n  }\n\n  public destroy() {\n    super.destroy();\n\n    this.modifiers?.forEach((modifier) => modifier.destroy());\n  }\n}\n","import {derived, effects, reactive, type Effect} from '@dnd-kit/state';\nimport type {Shape} from '@dnd-kit/geometry';\n\nimport {Entity} from '../entity/index.ts';\nimport type {EntityInput, Data, Type} from '../entity/index.ts';\nimport {\n  CollisionPriority,\n  type CollisionDetector,\n} from '../../collision/index.ts';\nimport type {DragDropManager} from '../../manager/index.ts';\nimport {Draggable} from '../draggable/draggable.ts';\n\nexport interface Input<T extends Data = Data> extends EntityInput<T> {\n  accept?: Type | Type[] | ((source: Draggable) => boolean);\n  collisionPriority?: CollisionPriority | number;\n  collisionDetector: CollisionDetector;\n  type?: Type;\n}\n\nexport class Droppable<T extends Data = Data> extends Entity<T> {\n  constructor(\n    {\n      accept,\n      collisionDetector,\n      collisionPriority = CollisionPriority.Normal,\n      type,\n      ...input\n    }: Input<T>,\n    public manager: DragDropManager\n  ) {\n    super(input, manager);\n\n    this.accept = accept;\n    this.collisionDetector = collisionDetector;\n    this.collisionPriority = collisionPriority;\n    this.type = type;\n  }\n\n  /**\n   * An array of types that are compatible with the droppable.\n   */\n  @reactive\n  public accept:\n    | Type\n    | Type[]\n    | ((draggable: Draggable) => boolean)\n    | undefined;\n\n  /**\n   * The type of the droppable.\n   */\n  @reactive\n  public type: Type | undefined;\n\n  /**\n   * Checks whether or not the droppable accepts a given draggable.\n   *\n   * @param {Draggable} draggable\n   * @returns {boolean}\n   */\n  public accepts(draggable: Draggable): boolean {\n    const {accept} = this;\n\n    if (!accept) {\n      return true;\n    }\n\n    if (!draggable.type) {\n      return false;\n    }\n\n    if (Array.isArray(accept)) {\n      return accept.includes(draggable.type);\n    }\n\n    if (typeof accept === 'function') {\n      return accept(draggable);\n    }\n\n    return draggable.type === accept;\n  }\n\n  @reactive\n  public collisionDetector: CollisionDetector;\n\n  @reactive\n  public collisionPriority: number;\n\n  @reactive\n  public shape: Shape | undefined;\n\n  @derived\n  public get isDropTarget() {\n    return this.manager.dragOperation.target?.id === this.id;\n  }\n\n  public refreshShape() {\n    // To be implemented by subclasses\n  }\n}\n","import {CleanupFunction} from '@dnd-kit/state';\n\nimport type {DragDropManager} from '../manager/index.ts';\nimport type {Draggable} from '../entities/index.ts';\nimport {\n  Plugin,\n  type PluginConstructor,\n  type PluginDescriptor,\n  type PluginOptions,\n} from '../plugins/index.ts';\n\nexport type SensorOptions = PluginOptions;\n\nexport abstract class Sensor<\n  T extends DragDropManager<any, any> = DragDropManager,\n  U extends SensorOptions = SensorOptions,\n> extends Plugin<T, U> {\n  constructor(\n    public manager: T,\n    public options?: U\n  ) {\n    super(manager, options);\n  }\n\n  /**\n   * Bind the sensor to a draggable source, and optionally pass\n   * in sensor options to override the default sensor options\n   * for this draggable source only.\n   */\n  public abstract bind(source: Draggable, options?: U): CleanupFunction;\n}\n\nexport type SensorConstructor<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n> = PluginConstructor<T, Sensor<T>>;\n\nexport type SensorDescriptor<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n> = PluginDescriptor<T, Sensor<T>, SensorConstructor<T>>;\n\nexport type Sensors<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n> = (SensorConstructor<T> | SensorDescriptor<T>)[];\n","import type {Coordinates} from '@dnd-kit/geometry';\n\nimport {\n  Plugin,\n  type PluginOptions,\n  type PluginConstructor,\n  type PluginDescriptor,\n} from '../plugins/index.ts';\nimport type {DragDropManager} from '../manager/index.ts';\n\nexport type ModifierOptions = PluginOptions;\n\nexport class Modifier<\n  T extends DragDropManager<any, any> = DragDropManager,\n  U extends ModifierOptions = ModifierOptions,\n> extends Plugin<T, U> {\n  constructor(\n    public manager: T,\n    public options?: U\n  ) {\n    super(manager, options);\n  }\n\n  public apply(operation: T['dragOperation']): Coordinates {\n    return operation.transform;\n  }\n}\n\nexport type ModifierConstructor<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n> = PluginConstructor<T, Modifier<T, any>>;\n\nexport type ModifierDescriptor<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n> = PluginDescriptor<T, Modifier<T, any>, ModifierConstructor<T>>;\n\nexport type Modifiers<\n  T extends DragDropManager<any, any> = DragDropManager<any, any>,\n> = (ModifierConstructor<T> | ModifierDescriptor<T>)[];\n","import type {CleanupFunction} from '@dnd-kit/state';\n\nimport {\n  Draggable,\n  Droppable,\n  Entity,\n  EntityRegistry,\n} from '../entities/index.ts';\nimport {\n  PluginRegistry,\n  Plugin,\n  type PluginConstructor,\n  PluginOptions,\n} from '../plugins/index.ts';\nimport {\n  Sensor,\n  SensorOptions,\n  type SensorConstructor,\n} from '../sensors/index.ts';\nimport {Modifier, type ModifierConstructor} from '../modifiers/index.ts';\nimport type {DragDropManager} from './manager.ts';\n\nexport class DragDropRegistry<\n  T extends Draggable,\n  U extends Droppable,\n  V extends DragDropManager<T, U>,\n> {\n  constructor(manager: V) {\n    this.plugins = new PluginRegistry<V, PluginConstructor<V>>(manager);\n    this.sensors = new PluginRegistry<V, SensorConstructor<V>>(manager);\n    this.modifiers = new PluginRegistry<V, ModifierConstructor<V>>(manager);\n  }\n\n  public draggables = new EntityRegistry<T>();\n  public droppables = new EntityRegistry<U>();\n  public plugins: PluginRegistry<V, PluginConstructor<V>>;\n  public sensors: PluginRegistry<V, SensorConstructor<V>>;\n  public modifiers: PluginRegistry<V, ModifierConstructor<V>>;\n\n  public register(input: Entity): () => void;\n  public register(input: Draggable): () => void;\n  public register(input: Droppable): () => void;\n  public register(input: SensorConstructor, options?: SensorOptions): Sensor;\n  public register(input: ModifierConstructor): Modifier;\n  public register(input: PluginConstructor, options?: PluginOptions): Plugin;\n  public register(input: any, options?: Record<string, any>) {\n    if (input instanceof Draggable) {\n      return this.draggables.register(input.id, input as T);\n    }\n\n    if (input instanceof Droppable) {\n      return this.droppables.register(input.id, input as U);\n    }\n\n    if (input.prototype instanceof Modifier) {\n      return this.modifiers.register(input, options);\n    }\n\n    if (input.prototype instanceof Sensor) {\n      return this.sensors.register(input, options);\n    }\n\n    if (input.prototype instanceof Plugin) {\n      return this.plugins.register(input, options);\n    }\n\n    throw new Error('Invalid instance type');\n  }\n\n  public unregister(input: Entity): CleanupFunction;\n  public unregister(input: Draggable): CleanupFunction;\n  public unregister(input: Droppable): CleanupFunction;\n  public unregister(input: SensorConstructor): CleanupFunction;\n  public unregister(input: ModifierConstructor): CleanupFunction;\n  public unregister(input: PluginConstructor): CleanupFunction;\n  public unregister(input: any) {\n    if (input instanceof Entity) {\n      if (input instanceof Draggable) {\n        return this.draggables.unregister(input.id, input as T);\n      }\n\n      if (input instanceof Droppable) {\n        return this.droppables.unregister(input.id, input as U);\n      }\n\n      // no-op\n      return () => {};\n    }\n\n    if (input.prototype instanceof Modifier) {\n      return this.modifiers.unregister(input);\n    }\n\n    if (input.prototype instanceof Sensor) {\n      return this.sensors.unregister(input);\n    }\n\n    if (input.prototype instanceof Plugin) {\n      return this.plugins.unregister(input);\n    }\n\n    throw new Error('Invalid instance type');\n  }\n\n  destroy() {\n    this.draggables.destroy();\n    this.droppables.destroy();\n    this.plugins.destroy();\n    this.sensors.destroy();\n    this.modifiers.destroy();\n  }\n}\n","import {Position, type Shape} from '@dnd-kit/geometry';\nimport type {Coordinates} from '@dnd-kit/geometry';\nimport {batch, computed, signal} from '@dnd-kit/state';\n\nimport type {\n  Draggable,\n  Droppable,\n  UniqueIdentifier,\n} from '../entities/index.ts';\n\nimport type {DragDropManager} from './manager.ts';\nimport {defaultPreventable} from './events.ts';\n\nexport enum Status {\n  Idle = 'idle',\n  Initializing = 'initializing',\n  Dragging = 'dragging',\n  Dropped = 'dropped',\n}\n\nexport type Serializable = {\n  [key: string]: string | number | null | Serializable | Serializable[];\n};\n\nexport interface DragOperation<\n  T extends Draggable = Draggable,\n  U extends Droppable = Droppable,\n> {\n  activatorEvent: Event | null;\n  canceled: boolean;\n  position: Position;\n  transform: Coordinates;\n  status: {\n    current: Status;\n    initialized: boolean;\n    initializing: boolean;\n    dragging: boolean;\n    dragended: boolean;\n    dropped: boolean;\n    idle: boolean;\n  };\n  get shape(): {\n    initial: Shape;\n    current: Shape;\n  } | null;\n  set shape(value: Shape | null);\n  source: T | null;\n  target: U | null;\n  data?: Serializable;\n}\n\nexport type DragActions<\n  T extends Draggable,\n  U extends Droppable,\n  V extends DragDropManager<T, U>,\n> = ReturnType<typeof DragOperationManager<T, U, V>>['actions'];\n\nexport function DragOperationManager<\n  T extends Draggable,\n  U extends Droppable,\n  V extends DragDropManager<T, U>,\n>(manager: V) {\n  const {\n    registry: {draggables, droppables},\n    monitor,\n  } = manager;\n  const status = signal<Status>(Status.Idle);\n  const shape = {\n    initial: signal<Shape | null>(null),\n    current: signal<Shape | null>(null),\n  };\n  const canceled = signal<boolean>(false);\n  const position = new Position({x: 0, y: 0});\n  const activatorEvent = signal<Event | null>(null);\n  const sourceIdentifier = signal<UniqueIdentifier | null>(null);\n  const targetIdentifier = signal<UniqueIdentifier | null>(null);\n  const dragging = computed(() => status.value === Status.Dragging);\n  const initialized = computed(() => status.value !== Status.Idle);\n  const initializing = computed(() => status.value === Status.Initializing);\n  const idle = computed(() => status.value === Status.Idle);\n  const dropped = computed(() => status.value === Status.Dropped);\n  const dragended = signal<boolean>(true);\n  let previousSource: T | undefined;\n  const source = computed<T | null>(() => {\n    const identifier = sourceIdentifier.value;\n\n    if (identifier == null) return null;\n\n    const value = draggables.get(identifier);\n\n    if (value) {\n      // It's possible for the source to unmount during the drag operation\n      previousSource = value;\n    }\n\n    return value ?? previousSource ?? null;\n  });\n  const target = computed<U | null>(() => {\n    const identifier = targetIdentifier.value;\n    return identifier != null ? droppables.get(identifier) ?? null : null;\n  });\n\n  const transform = computed(() => {\n    const {x, y} = position.delta;\n    const modifiers = source?.value?.modifiers ?? manager.modifiers;\n\n    let transform = {x, y};\n    const initialShape = shape.initial.peek();\n    const currentShape = shape.current.peek();\n    const operation: Omit<DragOperation<T, U>, 'transform'> = {\n      activatorEvent: activatorEvent.peek(),\n      canceled: canceled.peek(),\n      source: source.peek(),\n      target: target.peek(),\n      status: {\n        current: status.peek(),\n        idle: idle.peek(),\n        initializing: initializing.peek(),\n        initialized: initialized.peek(),\n        dragging: dragging.peek(),\n        dragended: dragended.peek(),\n        dropped: dropped.peek(),\n      },\n      shape:\n        initialShape && currentShape\n          ? {initial: initialShape, current: currentShape}\n          : null,\n      position,\n    };\n\n    for (const modifier of modifiers) {\n      transform = modifier.apply({...operation, transform});\n    }\n\n    return transform;\n  });\n\n  const operation: DragOperation<T, U> = {\n    get activatorEvent() {\n      return activatorEvent.value;\n    },\n    get canceled() {\n      return canceled.value;\n    },\n    get source() {\n      return source.value;\n    },\n    get target() {\n      return target.value;\n    },\n    status: {\n      get current() {\n        return status.value;\n      },\n      get idle() {\n        return idle.value;\n      },\n      get initializing() {\n        return initializing.value;\n      },\n      get initialized() {\n        return initialized.value;\n      },\n      get dragging() {\n        return dragging.value;\n      },\n      get dragended() {\n        return dragended.value;\n      },\n      get dropped() {\n        return dropped.value;\n      },\n    },\n    get shape(): DragOperation['shape'] {\n      const initial = shape.initial.value;\n      const current = shape.current.value;\n\n      return initial && current ? {initial, current} : null;\n    },\n    set shape(value: Shape | null) {\n      if (value && shape.current.peek()?.equals(value)) {\n        return;\n      }\n\n      const initial = shape.initial.peek();\n\n      if (!initial) {\n        shape.initial.value = value;\n      }\n\n      shape.current.value = value;\n    },\n    get transform() {\n      return transform.value;\n    },\n    position,\n  };\n\n  const reset = () => {\n    batch(() => {\n      status.value = Status.Idle;\n      sourceIdentifier.value = null;\n      targetIdentifier.value = null;\n      shape.current.value = null;\n      shape.initial.value = null;\n      position.reset({x: 0, y: 0});\n    });\n  };\n\n  return {\n    operation,\n    actions: {\n      setDragSource(identifier: UniqueIdentifier) {\n        sourceIdentifier.value = identifier;\n      },\n      setDropTarget(\n        identifier: UniqueIdentifier | null | undefined\n      ): Promise<void> {\n        const id = identifier ?? null;\n\n        if (targetIdentifier.peek() === id) {\n          return Promise.resolve();\n        }\n\n        targetIdentifier.value = id;\n\n        if (status.peek() === Status.Dragging) {\n          monitor.dispatch(\n            'dragover',\n            defaultPreventable({\n              operation: snapshot(operation),\n            })\n          );\n        }\n\n        return manager.renderer.rendering;\n      },\n      start({event, coordinates}: {event: Event; coordinates: Coordinates}) {\n        batch(() => {\n          dragended.value = false;\n          canceled.value = false;\n          activatorEvent.value = event;\n          position.reset(coordinates);\n        });\n\n        const beforeStartEvent = defaultPreventable({\n          operation: snapshot(operation),\n        });\n\n        monitor.dispatch('beforedragstart', beforeStartEvent);\n\n        manager.renderer.rendering.then(() => {\n          if (beforeStartEvent.defaultPrevented) {\n            reset();\n            return;\n          }\n\n          status.value = Status.Initializing;\n\n          requestAnimationFrame(() => {\n            status.value = Status.Dragging;\n\n            monitor.dispatch('dragstart', {\n              operation: snapshot(operation),\n              cancelable: false,\n            });\n          });\n        });\n      },\n      move({\n        by,\n        to,\n        cancelable = true,\n      }:\n        | {by: Coordinates; to?: undefined; cancelable?: boolean}\n        | {by?: undefined; to: Coordinates; cancelable?: boolean}) {\n        if (!dragging.peek()) {\n          return;\n        }\n\n        const event = defaultPreventable(\n          {\n            operation: snapshot(operation),\n            by,\n            to,\n          },\n          cancelable\n        );\n\n        monitor.dispatch('dragmove', event);\n\n        queueMicrotask(() => {\n          if (event.defaultPrevented) {\n            return;\n          }\n\n          const coordinates = to ?? {\n            x: position.current.x + by.x,\n            y: position.current.y + by.y,\n          };\n\n          position.update(coordinates);\n        });\n      },\n      stop({canceled: eventCanceled = false}: {canceled?: boolean} = {}) {\n        let promise: Promise<void> | undefined;\n        const suspend = () => {\n          const output = {\n            resume: () => {},\n            abort: () => {},\n          };\n\n          promise = new Promise<void>((resolve, reject) => {\n            output.resume = resolve;\n            output.abort = reject;\n          });\n\n          return output;\n        };\n        const end = () => {\n          /* Wait for the renderer to finish rendering before finalizing the drag operation */\n          manager.renderer.rendering.then(() => {\n            status.value = Status.Dropped;\n            manager.renderer.rendering.then(reset);\n          });\n        };\n\n        batch(() => {\n          dragended.value = true;\n          canceled.value = eventCanceled;\n        });\n\n        monitor.dispatch('dragend', {\n          operation: snapshot(operation),\n          canceled: eventCanceled,\n          suspend,\n        });\n\n        if (promise) {\n          promise.then(end).catch(reset);\n        } else {\n          end();\n        }\n      },\n    },\n  };\n}\n\nfunction snapshot<T extends Record<string, any>>(obj: T): T {\n  return {\n    ...obj,\n  };\n}\n","export interface Renderer {\n  get rendering(): Promise<void>;\n}\n\nexport const defaultRenderer: Renderer = {\n  get rendering() {\n    return Promise.resolve();\n  },\n};\n","import type {Draggable, Droppable} from '../entities/index.ts';\nimport {CollisionObserver, CollisionNotifier} from '../collision/index.ts';\nimport type {Plugins, Plugin} from '../plugins/index.ts';\nimport type {Sensor, Sensors} from '../sensors/index.ts';\nimport type {Modifier, Modifiers} from '../modifiers/index.ts';\n\nimport {DragDropRegistry} from './registry.ts';\nimport {\n  DragOperationManager,\n  type DragOperation,\n  type DragActions,\n} from './dragOperation.ts';\nimport {DragDropMonitor} from './events.ts';\nimport {defaultRenderer, type Renderer} from './renderer.ts';\n\nexport type DragDropManagerInput<T extends DragDropManager<any, any>> = {\n  plugins?: Plugins<T>;\n  sensors?: Sensors<T>;\n  modifiers?: Modifiers<T>;\n  renderer?: Renderer;\n};\n\nexport class DragDropManager<\n  T extends Draggable = Draggable,\n  U extends Droppable = Droppable,\n> {\n  public actions: DragActions<T, U, DragDropManager<T, U>>;\n  public collisionObserver: CollisionObserver<T, U>;\n  public dragOperation: DragOperation<T, U>;\n  public monitor: DragDropMonitor<T, U, DragDropManager<T, U>>;\n  public registry: DragDropRegistry<T, U, DragDropManager<T, U>>;\n  public renderer: Renderer;\n\n  constructor(config?: DragDropManagerInput<any>) {\n    type V = DragDropManager<T, U>;\n\n    const {\n      plugins = [],\n      sensors = [],\n      modifiers = [],\n      renderer = defaultRenderer,\n    } = config ?? {};\n    const monitor = new DragDropMonitor<T, U, V>(this);\n    const registry = new DragDropRegistry<T, U, V>(this);\n\n    this.registry = registry;\n    this.monitor = monitor;\n    this.renderer = renderer;\n\n    const {actions, operation} = DragOperationManager<T, U, V>(this);\n\n    this.actions = actions;\n    this.dragOperation = operation;\n    this.collisionObserver = new CollisionObserver<T, U, V>(this);\n    this.plugins = [CollisionNotifier, ...plugins];\n    this.modifiers = modifiers;\n    this.sensors = sensors;\n  }\n\n  get plugins(): Plugin<any>[] {\n    return this.registry.plugins.values;\n  }\n\n  set plugins(plugins: Plugins<any>) {\n    this.registry.plugins.values = plugins;\n  }\n\n  get modifiers(): Modifier<any>[] {\n    return this.registry.modifiers.values;\n  }\n\n  set modifiers(modifiers: Modifiers<any>) {\n    this.registry.modifiers.values = modifiers;\n  }\n\n  get sensors(): Sensor<any>[] {\n    return this.registry.sensors.values;\n  }\n\n  set sensors(sensors: Sensors<any>) {\n    this.registry.sensors.values = sensors;\n  }\n\n  public destroy() {\n    this.registry.destroy();\n    this.collisionObserver.destroy();\n  }\n}\n"]}